# Cursor AI Rules for cfFormMailer

## Project Context

- Project: cfFormMailer - Mail Form Snippet for MODX Evolution
- Version: v1.7.0 (stable), v2.0.0 (in development)
- PHP: 7.4 - 8.4
- License: GPL
- Status: Refactoring from legacy (2,481-line monolithic class) to modern architecture

## Core Principles

1. **100% Backward Compatibility**: All v1.7.x features must work in v2.0
2. **Type Safety**: Strict type declarations required (`declare(strict_types=1)`)
3. **Single Responsibility**: Each class should have one clear purpose (100-300 lines)
4. **Test-Driven**: Write tests before implementation (90%+ coverage target)
5. **PHP 7.4~8.4 Compatible**: No PHP 8.0+ only features in production code

## Architecture

### Directory Structure (v2.0)

```
src/
├── Core/          # Form processing flow, config, session
├── Validation/    # 19+ validation rules as separate classes
│   └── Rules/
├── Mail/          # Admin & auto-reply mail sending
├── Template/      # Template engine, placeholders, filters
│   └── Filters/
├── Upload/        # File upload (replacing class.upload.php)
├── Database/      # Form data persistence
└── Legacy/        # Backward compatibility wrapper
```

### Key Patterns

- **DTOs**: Immutable data transfer objects (e.g., `ValidationResult`, `UploadedFile`)
- **Interfaces**: Define contracts (e.g., `ValidationRuleInterface`, `FilterInterface`)
- **Factories**: Create instances (e.g., `RuleFactory`)
- **Exceptions**: Use typed exceptions (e.g., `ValidationException`)

## Coding Standards

### Naming Conventions

```php
// Classes: PascalCase, singular, descriptive
class EmailRule {}
class FormValidator {}
class MailSender {}

// Methods: camelCase, start with verb
public function validate(array $data): ValidationResult
public function sendMail(array $formData): bool

// Properties: camelCase
private array $rules = [];
private ?ValidationResult $lastResult = null;
```

### Type Declarations (Required)

```php
<?php declare(strict_types=1);  // ALWAYS at file start

namespace CfFormMailer\Validation\Rules;

class EmailRule implements ValidationRuleInterface
{
    private string $errorMessage = 'Invalid email format';

    public function validate(mixed $value, array $params): bool
    {
        // Implementation
    }

    public function getErrorMessage(): string
    {
        return $this->errorMessage;
    }
}
```

### PHPDoc (When needed)

```php
/**
 * Validate form input
 *
 * @param array<string, mixed> $data Input data to validate
 * @return ValidationResult Validation result with errors
 * @throws ValidationException When validation rules are invalid
 */
public function validate(array $data): ValidationResult
{
    // ...
}
```

## File Templates

### Validation Rule

```php
<?php declare(strict_types=1);

namespace CfFormMailer\Validation\Rules;

/**
 * {RuleName} validation rule
 */
class {RuleName}Rule implements ValidationRuleInterface
{
    public function validate(mixed $value, array $params): bool
    {
        // Validation logic
        return true;
    }

    public function getErrorMessage(): string
    {
        return 'Error message in Japanese';
    }

    public function transform(mixed $value): mixed
    {
        // Optional: normalize input (e.g., mb_convert_kana)
        return $value;
    }
}
```

### Template Filter

```php
<?php declare(strict_types=1);

namespace CfFormMailer\Template\Filters;

/**
 * {FilterName} filter
 *
 * Usage: [+field|{filter_name}+]
 */
class {FilterName}Filter implements FilterInterface
{
    public function apply(mixed $value, string $param): string
    {
        // Filter logic
        return (string) $value;
    }
}
```

### Unit Test

```php
<?php

namespace CfFormMailer\Tests\Unit\Validation\Rules;

use PHPUnit\Framework\TestCase;
use CfFormMailer\Validation\Rules\{RuleName}Rule;

class {RuleName}RuleTest extends TestCase
{
    private {RuleName}Rule $rule;

    protected function setUp(): void
    {
        $this->rule = new {RuleName}Rule();
    }

    /** @test */
    public function 有効な値を受理する(): void
    {
        $this->assertTrue($this->rule->validate('valid', []));
    }

    /** @test */
    public function 無効な値を拒否する(): void
    {
        $this->assertFalse($this->rule->validate('invalid', []));
    }
}
```

## Common Tasks

### Adding a New Validation Rule

1. Create `src/Validation/Rules/{Name}Rule.php`
2. Implement `ValidationRuleInterface`
3. Create test `tests/Unit/Validation/Rules/{Name}RuleTest.php`
4. Register in `RuleFactory::create()`
5. Run tests: `vendor/bin/phpunit`

### Adding a New Template Filter

1. Create `src/Template/Filters/{Name}Filter.php`
2. Implement `FilterInterface`
3. Register in `FilterRegistry::get()`
4. Add test

### Refactoring Legacy Code

1. Find method in `includes/class.cfFormMailer.inc.php` (e.g., `_def_email()`)
2. Create new class (e.g., `EmailRule`)
3. Write tests first (TDD)
4. Move logic to new class
5. Keep legacy method as wrapper (backward compatibility)

## Security Rules

1. **Input Validation**: Always validate external input
2. **Output Escaping**: Escape HTML output (`htmlspecialchars`)
3. **CSRF Protection**: Verify tokens on form submission
4. **File Upload**: Validate MIME type from file content (not extension)
5. **SQL Injection**: Use prepared statements

```php
// ✅ Good: Prepared statement
$stmt = $db->prepare('SELECT * FROM users WHERE email = ?');
$stmt->execute([$email]);

// ❌ Bad: String concatenation
$sql = "SELECT * FROM users WHERE email = '{$email}'";
```

## Testing Guidelines

- **Coverage Target**: 90%+ overall, 100% for Validation
- **Naming**: Japanese test method names with `@test` annotation
- **Structure**: Arrange-Act-Assert pattern
- **Run**: `vendor/bin/phpunit`
- **Coverage**: `vendor/bin/phpunit --coverage-html coverage`

## Dependencies

### Allowed

- PHPUnit (dev): ^9.5
- PHPStan (dev): ^1.10
- PHP standard extensions: mbstring, fileinfo, gd/imagick (optional)

### Not Allowed

- Heavy frameworks (Laravel, Symfony)
- External file upload libraries (we implement lightweight version)
- Template engines requiring Composer (Twig is optional)

## MODX Integration

### Abstraction Pattern

```php
// ❌ Don't: Direct MODX dependency
global $modx;
$content = $modx->parseDocumentSource($tpl);

// ✅ Do: Use interface
interface ModxInterface
{
    public function parseDocumentSource(string $content): string;
}

class TemplateEngine
{
    public function __construct(private ModxInterface $modx) {}
}
```

## Error Messages

- **Language**: Japanese (日本語)
- **Format**: User-friendly, actionable
- **Examples**:
  - ✅ "メールアドレスの形式が正しくありません"
  - ✅ "18歳以上120歳以下の数値を入力してください"
  - ❌ "Invalid input"
  - ❌ "Error"

## Documentation

When creating new features:

1. Add code comments (Japanese OK)
2. Update relevant docs in `docs/`
3. Add examples to `docs/AGENTS.md`

## References

- `docs/AGENTS.md` - AI development guide
- `docs/REFACTORING_PROPOSAL.md` - Architecture design
- `docs/USER_EXPERIENCE_PROPOSAL.md` - UX improvements
- `docs/MIGRATION_GUIDE.md` - v1.7 → v2.0 migration

## Version Compatibility

### PHP 7.4 Compatibility

```php
// ✅ OK: Works on PHP 7.4+
private array $rules = [];

// ❌ Avoid: PHP 8.0+ only (constructor property promotion)
public function __construct(private array $rules) {}

// ✅ Use instead:
private array $rules;
public function __construct(array $rules) {
    $this->rules = $rules;
}
```

### strftime() Replacement

```php
// ❌ Deprecated in PHP 8.1+
strftime('%Y-%m-%d', $timestamp);

// ✅ Use DateTime
$dt = (new DateTime())->setTimestamp($timestamp);
$dt->format('Y-m-d');
```

## Quick Commands

```bash
# Autoload regeneration
composer dump-autoload

# Run all tests
vendor/bin/phpunit

# Run specific test
vendor/bin/phpunit tests/Unit/Validation/Rules/EmailRuleTest.php

# Static analysis
vendor/bin/phpstan analyse src

# Code style check (if configured)
vendor/bin/php-cs-fixer fix --dry-run
```

---

Last Updated: 2025-11-18
